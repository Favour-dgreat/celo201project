{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { PUBLISHER_CONTEXT, HEARTBEAT_EVENTS, PUBLISHER_DEFAULT_TTL } from \"../constants\";\nimport { getRelayProtocolName, getRelayProtocolApi } from \"./relayer\";\nimport { IEvents } from \"@walletconnect/jsonrpc-types\";\nexport class IPublisher extends IEvents {\n  constructor(relayer, logger) {\n    super();\n    this.relayer = relayer;\n    this.logger = logger;\n  }\n\n}\nexport class Publisher extends IPublisher {\n  constructor(relayer, logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = logger;\n    this.events = new EventEmitter();\n    this.name = PUBLISHER_CONTEXT;\n    this.queue = new Map();\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.initialize();\n  }\n\n  async publish(topic, payload, opts) {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"publish\",\n      params: {\n        topic,\n        payload,\n        opts\n      }\n    });\n\n    try {\n      const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || PUBLISHER_DEFAULT_TTL;\n      const relay = getRelayProtocolName(opts);\n      const params = {\n        topic,\n        payload,\n        opts: {\n          ttl,\n          relay\n        }\n      };\n      this.queue.set(payload.id, params);\n      const message = await this.relayer.encoder.encode(topic, payload);\n      await this.rpcPublish(topic, message, ttl, relay);\n      await this.onPublish(payload.id, params);\n      this.logger.debug(`Successfully Published Payload`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic,\n          payload,\n          opts\n        }\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async initialize() {}\n\n  async rpcPublish(topic, message, ttl, relay) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request = {\n      method: api.publish,\n      params: {\n        topic,\n        message,\n        ttl\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.relayer.provider.request(request);\n  }\n\n  async onPublish(id, params) {\n    this.queue.delete(id);\n  }\n\n  checkQueue() {\n    this.queue.forEach(async params => {\n      const {\n        topic,\n        payload,\n        opts: {\n          ttl,\n          relay\n        }\n      } = params;\n      const message = await this.relayer.encoder.encode(topic, payload);\n      await this.rpcPublish(topic, message, ttl, relay);\n      await this.onPublish(payload.id, params);\n    });\n  }\n\n  registerEventListeners() {\n    this.relayer.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.checkQueue();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/publisher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { PUBLISHER_CONTEXT, HEARTBEAT_EVENTS, PUBLISHER_DEFAULT_TTL } from \"../constants\";\nimport { getRelayProtocolName, getRelayProtocolApi } from \"./relayer\";\nimport { IEvents } from \"@walletconnect/jsonrpc-types\";\nexport class IPublisher extends IEvents {\n    constructor(relayer, logger) {\n        super();\n        this.relayer = relayer;\n        this.logger = logger;\n    }\n}\nexport class Publisher extends IPublisher {\n    constructor(relayer, logger) {\n        super(relayer, logger);\n        this.relayer = relayer;\n        this.logger = logger;\n        this.events = new EventEmitter();\n        this.name = PUBLISHER_CONTEXT;\n        this.queue = new Map();\n        this.relayer = relayer;\n        this.logger = generateChildLogger(logger, this.name);\n        this.registerEventListeners();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.initialize();\n    }\n    async publish(topic, payload, opts) {\n        this.logger.debug(`Publishing Payload`);\n        this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, payload, opts } });\n        try {\n            const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || PUBLISHER_DEFAULT_TTL;\n            const relay = getRelayProtocolName(opts);\n            const params = { topic, payload, opts: { ttl, relay } };\n            this.queue.set(payload.id, params);\n            const message = await this.relayer.encoder.encode(topic, payload);\n            await this.rpcPublish(topic, message, ttl, relay);\n            await this.onPublish(payload.id, params);\n            this.logger.debug(`Successfully Published Payload`);\n            this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, payload, opts } });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Publish Payload`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async initialize() {\n    }\n    async rpcPublish(topic, message, ttl, relay) {\n        const api = getRelayProtocolApi(relay.protocol);\n        const request = {\n            method: api.publish,\n            params: {\n                topic,\n                message,\n                ttl,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.relayer.provider.request(request);\n    }\n    async onPublish(id, params) {\n        this.queue.delete(id);\n    }\n    checkQueue() {\n        this.queue.forEach(async (params) => {\n            const { topic, payload, opts: { ttl, relay }, } = params;\n            const message = await this.relayer.encoder.encode(topic, payload);\n            await this.rpcPublish(topic, message, ttl, relay);\n            await this.onPublish(payload.id, params);\n        });\n    }\n    registerEventListeners() {\n        this.relayer.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n            this.checkQueue();\n        });\n    }\n}\n//# sourceMappingURL=publisher.js.map"]},"metadata":{},"sourceType":"module"}