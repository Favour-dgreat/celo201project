{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport pino from \"pino\";\nimport KeyValueStorage from \"keyvaluestorage\";\nimport { generateChildLogger, getDefaultLoggerOptions, getLoggerContext } from \"@walletconnect/logger\";\nimport { IRelayer } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { formatRelayRpcUrl } from \"@walletconnect/utils\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport { isJsonRpcRequest, formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\nimport { Subscriber } from \"./subscriber\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_LOGGER, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIBER_SUFFIX, RELAYER_RECONNECT_TIMEOUT, RELAYER_STORAGE_OPTIONS, RELAYER_DEFAULT_RELAY_URL } from \"../constants\";\nimport { JsonRpcHistory } from \"./history\";\nimport { RelayerStorage } from \"./storage\";\nimport { RelayerEncoder } from \"./encoder\";\nimport { HeartBeat } from \"./heartbeat\";\nimport { Publisher } from \"./publisher\";\nexport class Relayer extends IRelayer {\n  constructor(opts) {\n    super(opts);\n    this.protocol = \"irn\";\n    this.version = 1;\n    this.events = new EventEmitter();\n    this.name = RELAYER_CONTEXT;\n    this.logger = typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== \"undefined\" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== \"string\" ? generateChildLogger(opts.logger, this.name) : pino(getDefaultLoggerOptions({\n      level: (opts === null || opts === void 0 ? void 0 : opts.logger) || RELAYER_DEFAULT_LOGGER\n    }));\n    const kvsOptions = Object.assign(Object.assign({}, RELAYER_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.keyValueStorageOptions);\n    this.storage = typeof (opts === null || opts === void 0 ? void 0 : opts.storage) !== \"undefined\" ? opts.storage : new RelayerStorage(this.logger, (opts === null || opts === void 0 ? void 0 : opts.keyValueStorage) || new KeyValueStorage(kvsOptions), {\n      protocol: this.protocol,\n      version: this.version,\n      context: this.context\n    });\n    this.heartbeat = (opts === null || opts === void 0 ? void 0 : opts.heartbeat) || new HeartBeat({\n      logger: this.logger\n    });\n    this.encoder = (opts === null || opts === void 0 ? void 0 : opts.encoder) || new RelayerEncoder();\n    const rpcUrl = (opts === null || opts === void 0 ? void 0 : opts.rpcUrl) || formatRelayRpcUrl(this.protocol, this.version, RELAYER_DEFAULT_RELAY_URL, opts === null || opts === void 0 ? void 0 : opts.projectId);\n    this.provider = typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== \"string\" && typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== \"undefined\" ? opts === null || opts === void 0 ? void 0 : opts.relayProvider : new JsonRpcProvider(new WsConnection(rpcUrl));\n    this.history = new JsonRpcHistory(this.logger, this.storage);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.history.init();\n    await this.provider.connect();\n    await this.subscriber.init();\n    await this.publisher.init();\n  }\n\n  async publish(topic, payload, opts) {\n    await this.publisher.publish(topic, payload, opts);\n    await this.recordPayloadEvent({\n      topic,\n      payload\n    });\n  }\n\n  async subscribe(topic, opts) {\n    const id = await this.subscriber.subscribe(topic, opts);\n    return id;\n  }\n\n  async unsubscribe(topic, opts) {\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async recordPayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n\n    if (isJsonRpcRequest(payload)) {\n      await this.history.set(topic, payload);\n    } else {\n      await this.history.resolve(payload);\n    }\n  }\n\n  async shouldIgnorePayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    if (!this.subscriber.topics.includes(topic)) return true;\n    let exists = false;\n\n    try {\n      if (isJsonRpcRequest(payload)) {\n        exists = await this.history.exists(topic, payload.id);\n      } else {\n        let record;\n\n        try {\n          record = await this.history.get(topic, payload.id);\n        } catch (e) {}\n\n        exists = typeof record !== \"undefined\" && typeof record.response !== \"undefined\";\n      }\n    } catch (e) {}\n\n    return exists;\n  }\n\n  async onPayload(payload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload\n    });\n\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = payload.params;\n      const {\n        topic,\n        message\n      } = event.data;\n      const payloadEvent = {\n        topic,\n        payload: await this.encoder.decode(topic, message)\n      };\n      if (await this.shouldIgnorePayloadEvent(payloadEvent)) return;\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace(Object.assign({\n        type: \"event\",\n        event: event.id\n      }, payloadEvent));\n      this.events.emit(event.id, payloadEvent);\n      this.events.emit(RELAYER_EVENTS.payload, payloadEvent);\n      await this.acknowledgePayload(payload);\n      await this.recordPayloadEvent(payloadEvent);\n    }\n  }\n\n  async acknowledgePayload(payload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  registerEventListeners() {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, payload => this.onPayload(payload));\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n      this.events.emit(RELAYER_EVENTS.connect);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n      this.events.emit(RELAYER_EVENTS.disconnect);\n      setTimeout(() => {\n        this.provider.connect();\n      }, RELAYER_RECONNECT_TIMEOUT);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));\n  }\n\n}\nexport function getRelayProtocolName(opts) {\n  return (opts === null || opts === void 0 ? void 0 : opts.relay) || {\n    protocol: RELAYER_DEFAULT_PROTOCOL\n  };\n}\nexport function getRelayProtocolApi(protocol) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n\n  return jsonrpc;\n}","map":{"version":3,"sources":["../../../src/controllers/relayer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport pino from \"pino\";\nimport KeyValueStorage from \"keyvaluestorage\";\nimport { generateChildLogger, getDefaultLoggerOptions, getLoggerContext, } from \"@walletconnect/logger\";\nimport { IRelayer, } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { formatRelayRpcUrl } from \"@walletconnect/utils\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport { isJsonRpcRequest, formatJsonRpcResult, } from \"@walletconnect/jsonrpc-utils\";\nimport { Subscriber } from \"./subscriber\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_LOGGER, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIBER_SUFFIX, RELAYER_RECONNECT_TIMEOUT, RELAYER_STORAGE_OPTIONS, RELAYER_DEFAULT_RELAY_URL, } from \"../constants\";\nimport { JsonRpcHistory } from \"./history\";\nimport { RelayerStorage } from \"./storage\";\nimport { RelayerEncoder } from \"./encoder\";\nimport { HeartBeat } from \"./heartbeat\";\nimport { Publisher } from \"./publisher\";\nexport class Relayer extends IRelayer {\n    constructor(opts) {\n        super(opts);\n        this.protocol = \"irn\";\n        this.version = 1;\n        this.events = new EventEmitter();\n        this.name = RELAYER_CONTEXT;\n        this.logger =\n            typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== \"undefined\" && typeof (opts === null || opts === void 0 ? void 0 : opts.logger) !== \"string\"\n                ? generateChildLogger(opts.logger, this.name)\n                : pino(getDefaultLoggerOptions({ level: (opts === null || opts === void 0 ? void 0 : opts.logger) || RELAYER_DEFAULT_LOGGER }));\n        const kvsOptions = Object.assign(Object.assign({}, RELAYER_STORAGE_OPTIONS), opts === null || opts === void 0 ? void 0 : opts.keyValueStorageOptions);\n        this.storage =\n            typeof (opts === null || opts === void 0 ? void 0 : opts.storage) !== \"undefined\"\n                ? opts.storage\n                : new RelayerStorage(this.logger, (opts === null || opts === void 0 ? void 0 : opts.keyValueStorage) || new KeyValueStorage(kvsOptions), {\n                    protocol: this.protocol,\n                    version: this.version,\n                    context: this.context,\n                });\n        this.heartbeat = (opts === null || opts === void 0 ? void 0 : opts.heartbeat) || new HeartBeat({ logger: this.logger });\n        this.encoder = (opts === null || opts === void 0 ? void 0 : opts.encoder) || new RelayerEncoder();\n        const rpcUrl = (opts === null || opts === void 0 ? void 0 : opts.rpcUrl) ||\n            formatRelayRpcUrl(this.protocol, this.version, RELAYER_DEFAULT_RELAY_URL, opts === null || opts === void 0 ? void 0 : opts.projectId);\n        this.provider =\n            typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== \"string\" && typeof (opts === null || opts === void 0 ? void 0 : opts.relayProvider) !== \"undefined\"\n                ? opts === null || opts === void 0 ? void 0 : opts.relayProvider : new JsonRpcProvider(new WsConnection(rpcUrl));\n        this.history = new JsonRpcHistory(this.logger, this.storage);\n        this.subscriber = new Subscriber(this, this.logger);\n        this.publisher = new Publisher(this, this.logger);\n        this.registerEventListeners();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get connected() {\n        return this.provider.connection.connected;\n    }\n    get connecting() {\n        return this.provider.connection.connecting;\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.history.init();\n        await this.provider.connect();\n        await this.subscriber.init();\n        await this.publisher.init();\n    }\n    async publish(topic, payload, opts) {\n        await this.publisher.publish(topic, payload, opts);\n        await this.recordPayloadEvent({ topic, payload });\n    }\n    async subscribe(topic, opts) {\n        const id = await this.subscriber.subscribe(topic, opts);\n        return id;\n    }\n    async unsubscribe(topic, opts) {\n        await this.subscriber.unsubscribe(topic, opts);\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async recordPayloadEvent(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (isJsonRpcRequest(payload)) {\n            await this.history.set(topic, payload);\n        }\n        else {\n            await this.history.resolve(payload);\n        }\n    }\n    async shouldIgnorePayloadEvent(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (!this.subscriber.topics.includes(topic))\n            return true;\n        let exists = false;\n        try {\n            if (isJsonRpcRequest(payload)) {\n                exists = await this.history.exists(topic, payload.id);\n            }\n            else {\n                let record;\n                try {\n                    record = await this.history.get(topic, payload.id);\n                }\n                catch (e) {\n                }\n                exists = typeof record !== \"undefined\" && typeof record.response !== \"undefined\";\n            }\n        }\n        catch (e) {\n        }\n        return exists;\n    }\n    async onPayload(payload) {\n        this.logger.debug(`Incoming Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n        if (isJsonRpcRequest(payload)) {\n            if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX))\n                return;\n            const event = payload.params;\n            const { topic, message } = event.data;\n            const payloadEvent = {\n                topic,\n                payload: await this.encoder.decode(topic, message),\n            };\n            if (await this.shouldIgnorePayloadEvent(payloadEvent))\n                return;\n            this.logger.debug(`Emitting Relayer Payload`);\n            this.logger.trace(Object.assign({ type: \"event\", event: event.id }, payloadEvent));\n            this.events.emit(event.id, payloadEvent);\n            this.events.emit(RELAYER_EVENTS.payload, payloadEvent);\n            await this.acknowledgePayload(payload);\n            await this.recordPayloadEvent(payloadEvent);\n        }\n    }\n    async acknowledgePayload(payload) {\n        const response = formatJsonRpcResult(payload.id, true);\n        await this.provider.connection.send(response);\n    }\n    registerEventListeners() {\n        this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));\n        this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n            this.events.emit(RELAYER_EVENTS.connect);\n        });\n        this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n            this.events.emit(RELAYER_EVENTS.disconnect);\n            setTimeout(() => {\n                this.provider.connect();\n            }, RELAYER_RECONNECT_TIMEOUT);\n        });\n        this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));\n    }\n}\nexport function getRelayProtocolName(opts) {\n    return (opts === null || opts === void 0 ? void 0 : opts.relay) || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\nexport function getRelayProtocolApi(protocol) {\n    const jsonrpc = RELAY_JSONRPC[protocol];\n    if (typeof jsonrpc === \"undefined\") {\n        throw new Error(`Relay Protocol not supported: ${protocol}`);\n    }\n    return jsonrpc;\n}\n//# sourceMappingURL=relayer.js.map"]},"metadata":{},"sourceType":"module"}