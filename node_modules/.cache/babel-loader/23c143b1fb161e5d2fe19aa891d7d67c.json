{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useWalletVersion = void 0;\n\nvar react_1 = require(\"react\");\n\nvar constants_1 = require(\"../constants\");\n\nvar fetchWCWallets_1 = __importDefault(require(\"./fetchWCWallets\"));\n\nvar VERSION_OVERRIDE = Object.freeze((_a = {}, _a[constants_1.WalletIds.Valora] = 1, _a[constants_1.WalletIds.CeloWallet] = 2, _a[constants_1.WalletIds.CeloTerminal] = 2, _a[constants_1.WalletIds.CeloDance] = 2, _a));\n\nfunction useWalletVersion(walletId) {\n  // TODO: decide if to use v1 or v2 as a default for unknown wallectconnect? Or if to expose both\n  var _a = __read((0, react_1.useState)(walletId ? null : 2), 2),\n      version = _a[0],\n      setVersion = _a[1];\n\n  (0, react_1.useEffect)(function () {\n    if (!walletId) {\n      return;\n    }\n\n    void (0, fetchWCWallets_1.default)().then(function (celoWallets) {\n      var wallet = celoWallets.find(function (appEntry) {\n        return appEntry.id === walletId;\n      });\n\n      if (wallet) {\n        var versionFromRegistry = Math.max.apply(Math, __spreadArray([], __read(wallet.versions.map(function (_) {\n          return parseInt(_, 10);\n        })), false));\n\n        if (VERSION_OVERRIDE[walletId] && VERSION_OVERRIDE[walletId] !== versionFromRegistry) {\n          console.warn(\"Override version found in registry(\".concat(versionFromRegistry, \") by hard-coded version(\").concat(VERSION_OVERRIDE[walletId], \") for \").concat(wallet.name));\n          setVersion(VERSION_OVERRIDE[walletId]);\n        } else {\n          setVersion(versionFromRegistry);\n        }\n      } else if (!VERSION_OVERRIDE[walletId]) {\n        throw new Error('Unknown wallectconnect wallet');\n      }\n    });\n  }, [walletId]);\n  return version;\n}\n\nexports.useWalletVersion = useWalletVersion;","map":{"version":3,"sources":["../../src/utils/useWalletVersion.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AAEA,IAAM,gBAAgB,GAA2B,MAAM,CAAC,MAAP,EAAa,EAAA,GAAA,EAAA,EAC5D,EAAA,CAAC,WAAA,CAAA,SAAA,CAAU,MAAX,CAAA,GAAoB,CADwC,EAE5D,EAAA,CAAC,WAAA,CAAA,SAAA,CAAU,UAAX,CAAA,GAAwB,CAFoC,EAG5D,EAAA,CAAC,WAAA,CAAA,SAAA,CAAU,YAAX,CAAA,GAA0B,CAHkC,EAI5D,EAAA,CAAC,WAAA,CAAA,SAAA,CAAU,SAAX,CAAA,GAAuB,CAJqC,EAK5D,EAL+C,EAAjD;;AAOA,SAAgB,gBAAhB,CAAiC,QAAjC,EAAqD;AACnD;AACM,MAAA,EAAA,GAAA,MAAA,CAAwB,CAAA,GAAA,OAAA,CAAA,QAAA,EAAwB,QAAQ,GAAG,IAAH,GAAU,CAA1C,CAAxB,EAAoE,CAApE,CAAA;AAAA,MAAC,OAAO,GAAA,EAAA,CAAA,CAAA,CAAR;AAAA,MAAU,UAAU,GAAA,EAAA,CAAA,CAAA,CAApB;;AAEN,GAAA,GAAA,OAAA,CAAA,SAAA,EAAU,YAAA;AACR,QAAI,CAAC,QAAL,EAAe;AACb;AACD;;AAED,SAAK,CAAA,GAAA,gBAAA,CAAA,OAAA,IAAiB,IAAjB,CAAsB,UAAC,WAAD,EAAY;AACrC,UAAM,MAAM,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAC,QAAD,EAAS;AAAK,eAAA,QAAQ,CAAC,EAAT,KAAA,QAAA;AAAwB,OAAvD,CAAf;;AACA,UAAI,MAAJ,EAAY;AACV,YAAM,mBAAmB,GAAG,IAAI,CAAC,GAAL,CAAQ,KAAR,CAAA,IAAA,EAAI,aAAA,CAAA,EAAA,EAAA,MAAA,CAC3B,MAAM,CAAC,QAAP,CAAgB,GAAhB,CAAoB,UAAC,CAAD,EAAE;AAAK,iBAAA,QAAQ,CAAC,CAAD,EAAR,EAAQ,CAAR;AAAe,SAA1C,CAD2B,CAAA,EACgB,KADhB,CAAJ,CAA5B;;AAIA,YACE,gBAAgB,CAAC,QAAD,CAAhB,IACA,gBAAgB,CAAC,QAAD,CAAhB,KAA+B,mBAFjC,EAGE;AACA,UAAA,OAAO,CAAC,IAAR,CACE,sCAAA,MAAA,CAAsC,mBAAtC,EAAyD,0BAAzD,EAAyD,MAAzD,CAAoF,gBAAgB,CAAC,QAAD,CAApG,EAA8G,QAA9G,EAA8G,MAA9G,CAAuH,MAAM,CAAC,IAA9H,CADF;AAGA,UAAA,UAAU,CAAC,gBAAgB,CAAC,QAAD,CAAjB,CAAV;AACD,SARD,MAQO;AACL,UAAA,UAAU,CAAC,mBAAD,CAAV;AACD;AACF,OAhBD,MAgBO,IAAI,CAAC,gBAAgB,CAAC,QAAD,CAArB,EAAiC;AACtC,cAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACD;AACF,KArBI,CAAL;AAsBD,GA3BD,EA2BG,CAAC,QAAD,CA3BH;AA6BA,SAAO,OAAP;AACD;;AAlCD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useWalletVersion = void 0;\nvar react_1 = require(\"react\");\nvar constants_1 = require(\"../constants\");\nvar fetchWCWallets_1 = __importDefault(require(\"./fetchWCWallets\"));\nvar VERSION_OVERRIDE = Object.freeze((_a = {},\n    _a[constants_1.WalletIds.Valora] = 1,\n    _a[constants_1.WalletIds.CeloWallet] = 2,\n    _a[constants_1.WalletIds.CeloTerminal] = 2,\n    _a[constants_1.WalletIds.CeloDance] = 2,\n    _a));\nfunction useWalletVersion(walletId) {\n    // TODO: decide if to use v1 or v2 as a default for unknown wallectconnect? Or if to expose both\n    var _a = __read((0, react_1.useState)(walletId ? null : 2), 2), version = _a[0], setVersion = _a[1];\n    (0, react_1.useEffect)(function () {\n        if (!walletId) {\n            return;\n        }\n        void (0, fetchWCWallets_1.default)().then(function (celoWallets) {\n            var wallet = celoWallets.find(function (appEntry) { return appEntry.id === walletId; });\n            if (wallet) {\n                var versionFromRegistry = Math.max.apply(Math, __spreadArray([], __read(wallet.versions.map(function (_) { return parseInt(_, 10); })), false));\n                if (VERSION_OVERRIDE[walletId] &&\n                    VERSION_OVERRIDE[walletId] !== versionFromRegistry) {\n                    console.warn(\"Override version found in registry(\".concat(versionFromRegistry, \") by hard-coded version(\").concat(VERSION_OVERRIDE[walletId], \") for \").concat(wallet.name));\n                    setVersion(VERSION_OVERRIDE[walletId]);\n                }\n                else {\n                    setVersion(versionFromRegistry);\n                }\n            }\n            else if (!VERSION_OVERRIDE[walletId]) {\n                throw new Error('Unknown wallectconnect wallet');\n            }\n        });\n    }, [walletId]);\n    return version;\n}\nexports.useWalletVersion = useWalletVersion;\n//# sourceMappingURL=useWalletVersion.js.map"]},"metadata":{},"sourceType":"script"}