{"ast":null,"code":"import { create as ipfsHttpClient } from \"ipfs-http-client\";\nimport axios from \"axios\"; // initialize IPFS\n\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\"); // mint an NFT\n\nexport const createNft = async (minterContract, performActions, _ref) => {\n  let {\n    name,\n    description,\n    ipfsImage,\n    ownerAddress\n  } = _ref;\n  await performActions(async kit => {\n    if (!name || !description || !ipfsImage) return;\n    const {\n      defaultAccount\n    } = kit; // convert NFT metadata to JSON format\n\n    const data = JSON.stringify({\n      name,\n      description,\n      image: ipfsImage,\n      owner: defaultAccount\n    });\n\n    try {\n      // save NFT metadata to IPFS\n      const added = await client.add(data); // IPFS url for uploaded metadata\n\n      const url = `https://ipfs.infura.io/ipfs/${added.path}`; // mint the NFT and save the IPFS url to the blockchain\n\n      let transaction = await minterContract.methods.safeMint(ownerAddress, url).send({\n        from: defaultAccount\n      });\n      return transaction;\n    } catch (error) {\n      console.log(\"Error uploading file: \", error);\n    }\n  });\n}; // function to upload a file to IPFS\n\nexport const uploadToIpfs = async e => {\n  const file = e.target.files[0];\n  if (!file) return;\n\n  try {\n    const added = await client.add(file, {\n      progress: prog => console.log(`received: ${prog}`)\n    });\n    return `https://ipfs.infura.io/ipfs/${added.path}`;\n  } catch (error) {\n    console.log(\"Error uploading file: \", error);\n  }\n}; // fetch all NFTs on the smart contract\n\nexport const getNfts = async minterContract => {\n  try {\n    const nfts = [];\n    const nftsLength = await minterContract.methods.totalSupply().call();\n\n    for (let i = 0; i < Number(nftsLength); i++) {\n      const nft = new Promise(async resolve => {\n        const res = await minterContract.methods.tokenURI(i).call();\n        const meta = await fetchNftMeta(res);\n        const owner = await fetchNftOwner(minterContract, i);\n        resolve({\n          index: i,\n          tokenId: i,\n          owner,\n          name: meta.data.name,\n          image: meta.data.image,\n          description: meta.data.description\n        });\n      });\n      nfts.push(nft);\n    }\n\n    return Promise.all(nfts);\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the metedata for an NFT from IPFS\n\nexport const fetchNftMeta = async ipfsUrl => {\n  try {\n    if (!ipfsUrl) return null;\n    const meta = await axios.get(ipfsUrl);\n    return meta;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the owner address of an NFT\n\nexport const fetchNftOwner = async (minterContract, index) => {\n  try {\n    return await minterContract.methods.ownerOf(index).call();\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the address that deployed the NFT contract\n\nexport const fetchNftContractOwner = async minterContract => {\n  try {\n    let owner = await minterContract.methods.owner().call();\n    return owner;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n};\nexport const transferOwnership = async (minterContract, ownerAddress, newAddress, tokenId, performActions) => {\n  try {\n    await performActions(async kit => {\n      const {\n        defaultAccount\n      } = kit;\n      console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n      await minterContract.methods.makeTransfer(ownerAddress, newAddress, tokenId).send({\n        from: defaultAccount\n      });\n    });\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};\nexport const getOwners = async minterContract => {\n  try {\n    const ownerCount = await minterContract.methods.getOwners().call();\n    return ownerCount;\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};","map":{"version":3,"sources":["/Users/dgreat/Gtas/celo201project/src/utils/minter.js"],"names":["create","ipfsHttpClient","axios","client","createNft","minterContract","performActions","name","description","ipfsImage","ownerAddress","kit","defaultAccount","data","JSON","stringify","image","owner","added","add","url","path","transaction","methods","safeMint","send","from","error","console","log","uploadToIpfs","e","file","target","files","progress","prog","getNfts","nfts","nftsLength","totalSupply","call","i","Number","nft","Promise","resolve","res","tokenURI","meta","fetchNftMeta","fetchNftOwner","index","tokenId","push","all","ipfsUrl","get","ownerOf","fetchNftContractOwner","transferOwnership","newAddress","makeTransfer","getOwners","ownerCount"],"mappings":"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","sourcesContent":["import { create as ipfsHttpClient } from \"ipfs-http-client\";\nimport axios from \"axios\";\n\n// initialize IPFS\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\");\n\n// mint an NFT\nexport const createNft = async (\n  minterContract,\n  performActions,\n  { name, description, ipfsImage, ownerAddress }\n) => {\n  await performActions(async (kit) => {\n    if (!name || !description || !ipfsImage) return;\n    const { defaultAccount } = kit;\n\n    // convert NFT metadata to JSON format\n    const data = JSON.stringify({\n      name,\n      description,\n      image: ipfsImage,\n      owner: defaultAccount\n    });\n\n    try {\n      // save NFT metadata to IPFS\n      const added = await client.add(data);\n\n      // IPFS url for uploaded metadata\n      const url = `https://ipfs.infura.io/ipfs/${added.path}`;\n\n      // mint the NFT and save the IPFS url to the blockchain\n      let transaction = await minterContract.methods\n        .safeMint(ownerAddress, url)\n        .send({ from: defaultAccount });\n\n      return transaction;\n    } catch (error) {\n      console.log(\"Error uploading file: \", error);\n    }\n  });\n};\n\n// function to upload a file to IPFS\nexport const uploadToIpfs = async (e) => {\n  const file = e.target.files[0];\n  if (!file) return;\n  try {\n    const added = await client.add(file, {\n      progress: (prog) => console.log(`received: ${prog}`),\n    });\n    return `https://ipfs.infura.io/ipfs/${added.path}`;\n  } catch (error) {\n    console.log(\"Error uploading file: \", error);\n  }\n};\n\n// fetch all NFTs on the smart contract\nexport const getNfts = async (minterContract) => {\n  try {\n    const nfts = [];\n    const nftsLength = await minterContract.methods.totalSupply().call();\n    for (let i = 0; i < Number(nftsLength); i++) {\n      const nft = new Promise(async (resolve) => {\n        const res = await minterContract.methods.tokenURI(i).call();\n        const meta = await fetchNftMeta(res);\n        const owner = await fetchNftOwner(minterContract, i);\n        resolve({\n          index: i,\n          tokenId: i,\n          owner,\n          name: meta.data.name,\n          image: meta.data.image,\n          description: meta.data.description        });\n      });\n      nfts.push(nft);\n    }\n    return Promise.all(nfts);\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the metedata for an NFT from IPFS\nexport const fetchNftMeta = async (ipfsUrl) => {\n  try {\n    if (!ipfsUrl) return null;\n    const meta = await axios.get(ipfsUrl);\n    return meta;\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the owner address of an NFT\nexport const fetchNftOwner = async (minterContract, index) => {\n  try {\n    return await minterContract.methods.ownerOf(index).call();\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the address that deployed the NFT contract\nexport const fetchNftContractOwner = async (minterContract) => {\n  try {\n    let owner = await minterContract.methods.owner().call();\n    return owner;\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\nexport const transferOwnership = async (\n  minterContract,\n  ownerAddress,\n  newAddress,\n  tokenId,\n  performActions\n) => {\n  try {\n    await performActions(async (kit) => {\n      const { defaultAccount } = kit;\n      console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n      await minterContract.methods\n        .makeTransfer(ownerAddress, newAddress, tokenId)\n        .send({ from: defaultAccount });\n    });\n  } catch (error) {\n    console.log({ error });\n  }\n};\n\nexport const getOwners = async (minterContract) => {\n  try {\n    const ownerCount = await minterContract.methods.getOwners().call();\n    return ownerCount;\n  } catch (error) {\n    console.log({ error });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}