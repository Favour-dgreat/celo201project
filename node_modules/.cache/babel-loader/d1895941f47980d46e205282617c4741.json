{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { ISubscriber } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext } from \"@walletconnect/utils\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { SUBSCRIBER_CONTEXT, SUBSCRIBER_EVENTS, RELAYER_PROVIDER_EVENTS, HEARTBEAT_EVENTS } from \"../constants\";\nimport { getRelayProtocolName, getRelayProtocolApi } from \"./relayer\";\nexport class SubscriberTopicMap {\n  constructor() {\n    this.map = new Map();\n  }\n\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n\n  set(topic, id) {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  }\n\n  get(topic) {\n    const ids = this.map.get(topic);\n    return ids || [];\n  }\n\n  exists(topic, id) {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  }\n\n  delete(topic, id) {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter(x => x !== id);\n\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n\n    this.map.set(topic, remaining);\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n}\nexport class Subscriber extends ISubscriber {\n  constructor(relayer, logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = logger;\n    this.subscriptions = new Map();\n    this.topicMap = new SubscriberTopicMap();\n    this.events = new EventEmitter();\n    this.name = SUBSCRIBER_CONTEXT;\n    this.pending = new Map();\n    this.cached = [];\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.initialize();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  async subscribe(topic, opts) {\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"subscribe\",\n      params: {\n        topic,\n        opts\n      }\n    });\n\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = {\n        topic,\n        relay\n      };\n      this.pending.set(topic, params);\n      const id = await this.rpcSubscribe(topic, relay);\n      await this.onSubscribe(id, params);\n      this.logger.debug(`Successfully Subscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic,\n          opts\n        }\n      });\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async unsubscribe(topic, opts) {\n    if (typeof (opts === null || opts === void 0 ? void 0 : opts.id) !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async enable() {\n    if (!this.cached.length) return;\n    this.onEnable();\n  }\n\n  async disable() {\n    if (this.cached.length) return;\n    this.onDisable();\n  }\n\n  async hasSubscription(id, topic) {\n    await this.isEnabled();\n    let result = false;\n\n    try {\n      const subscription = await this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {}\n\n    return result;\n  }\n\n  onEnable() {\n    this.cached = [];\n    this.events.emit(SUBSCRIBER_EVENTS.enabled);\n  }\n\n  onDisable() {\n    this.cached = this.values;\n    this.subscriptions.clear();\n    this.topicMap.clear();\n    this.events.emit(SUBSCRIBER_EVENTS.disabled);\n  }\n\n  async unsubscribeByTopic(topic, opts) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async id => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  async unsubscribeById(topic, id, opts) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic,\n        id,\n        opts\n      }\n    });\n\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = ERROR.DELETED.format({\n        context: formatMessageContext(this.context)\n      });\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic,\n          id,\n          opts\n        }\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async rpcSubscribe(topic, relay) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request = {\n      method: api.subscribe,\n      params: {\n        topic\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.relayer.provider.request(request);\n  }\n\n  async rpcUnsubscribe(topic, id, relay) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.relayer.provider.request(request);\n  }\n\n  async onSubscribe(id, params) {\n    await this.setSubscription(id, Object.assign(Object.assign({}, params), {\n      id\n    }));\n    this.pending.delete(params.topic);\n  }\n\n  async onResubscribe(id, params) {\n    await this.addSubscription(id, Object.assign(Object.assign({}, params), {\n      id\n    }));\n    this.pending.delete(params.topic);\n  }\n\n  async onUnsubscribe(topic, id, reason) {\n    this.events.removeAllListeners(id);\n\n    if (await this.hasSubscription(id, topic)) {\n      await this.deleteSubscription(id, reason);\n    }\n\n    await this.relayer.history.delete(topic);\n  }\n\n  async setSubscription(id, subscription) {\n    await this.isEnabled();\n    if (this.subscriptions.has(id)) return;\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id,\n      subscription\n    });\n    await this.addSubscription(id, subscription);\n  }\n\n  async addSubscription(id, subscription) {\n    this.subscriptions.set(id, Object.assign({}, subscription));\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  async getSubscription(id) {\n    await this.isEnabled();\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id\n    });\n    const subscription = this.subscriptions.get(id);\n\n    if (!subscription) {\n      const error = ERROR.NO_MATCHING_ID.format({\n        context: formatMessageContext(this.context),\n        id\n      });\n      throw new Error(error.message);\n    }\n\n    return subscription;\n  }\n\n  async deleteSubscription(id, reason) {\n    await this.isEnabled();\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id,\n      reason\n    });\n    const subscription = await this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, Object.assign(Object.assign({}, subscription), {\n      reason\n    }));\n  }\n\n  async persist() {\n    await this.relayer.storage.setRelayerSubscriptions(this.context, this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  async restore() {\n    try {\n      const persisted = await this.relayer.storage.getRelayerSubscriptions(this.context);\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n\n      if (this.subscriptions.size) {\n        const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n          context: formatMessageContext(this.context)\n        });\n        this.logger.error(error.message);\n        throw new Error(error.message);\n      }\n\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${formatMessageContext(this.context)}`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${formatMessageContext(this.context)}`);\n      this.logger.error(e);\n    }\n  }\n\n  async initialize() {\n    await this.restore();\n    await this.reset();\n    await this.enable();\n  }\n\n  async isEnabled() {\n    if (!this.cached.length) return;\n    return new Promise(resolve => {\n      this.events.once(SUBSCRIBER_EVENTS.enabled, () => resolve());\n    });\n  }\n\n  async reset() {\n    if (!this.cached.length) return;\n    await Promise.all(this.cached.map(async subscription => this.resubscribe(subscription)));\n  }\n\n  async resubscribe(subscription) {\n    const {\n      topic,\n      relay\n    } = subscription;\n    const params = {\n      topic,\n      relay\n    };\n    this.pending.set(params.topic, params);\n    const id = await this.rpcSubscribe(params.topic, params.relay);\n    await this.onResubscribe(id, params);\n\n    if (this.ids.includes(subscription.id)) {\n      const reason = ERROR.RESUBSCRIBED.format({\n        topic: subscription.topic\n      });\n      await this.deleteSubscription(subscription.id, reason);\n    }\n  }\n\n  async onConnect() {\n    await this.reset();\n    await this.enable();\n  }\n\n  async onDisconnect() {\n    await this.disable();\n  }\n\n  checkPending() {\n    this.pending.forEach(async params => {\n      const id = await this.rpcSubscribe(params.topic, params.relay);\n      await this.onSubscribe(id, params);\n    });\n  }\n\n  registerEventListeners() {\n    this.relayer.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.checkPending();\n    });\n    this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n      await this.onConnect();\n    });\n    this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n      await this.onDisconnect();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async createdEvent => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: createdEvent\n      });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async deletedEvent => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: deletedEvent\n      });\n      await this.persist();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/subscriber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { ISubscriber, } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext } from \"@walletconnect/utils\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { SUBSCRIBER_CONTEXT, SUBSCRIBER_EVENTS, RELAYER_PROVIDER_EVENTS, HEARTBEAT_EVENTS, } from \"../constants\";\nimport { getRelayProtocolName, getRelayProtocolApi } from \"./relayer\";\nexport class SubscriberTopicMap {\n    constructor() {\n        this.map = new Map();\n    }\n    get topics() {\n        return Array.from(this.map.keys());\n    }\n    set(topic, id) {\n        const ids = this.get(topic);\n        if (this.exists(topic, id))\n            return;\n        this.map.set(topic, [...ids, id]);\n    }\n    get(topic) {\n        const ids = this.map.get(topic);\n        return ids || [];\n    }\n    exists(topic, id) {\n        const ids = this.get(topic);\n        return ids.includes(id);\n    }\n    delete(topic, id) {\n        if (typeof id === \"undefined\") {\n            this.map.delete(topic);\n            return;\n        }\n        if (!this.map.has(topic))\n            return;\n        const ids = this.get(topic);\n        if (!this.exists(topic, id))\n            return;\n        const remaining = ids.filter(x => x !== id);\n        if (!remaining.length) {\n            this.map.delete(topic);\n            return;\n        }\n        this.map.set(topic, remaining);\n    }\n    clear() {\n        this.map.clear();\n    }\n}\nexport class Subscriber extends ISubscriber {\n    constructor(relayer, logger) {\n        super(relayer, logger);\n        this.relayer = relayer;\n        this.logger = logger;\n        this.subscriptions = new Map();\n        this.topicMap = new SubscriberTopicMap();\n        this.events = new EventEmitter();\n        this.name = SUBSCRIBER_CONTEXT;\n        this.pending = new Map();\n        this.cached = [];\n        this.relayer = relayer;\n        this.logger = generateChildLogger(logger, this.name);\n        this.registerEventListeners();\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.initialize();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get length() {\n        return this.subscriptions.size;\n    }\n    get ids() {\n        return Array.from(this.subscriptions.keys());\n    }\n    get values() {\n        return Array.from(this.subscriptions.values());\n    }\n    get topics() {\n        return this.topicMap.topics;\n    }\n    async subscribe(topic, opts) {\n        this.logger.debug(`Subscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n        try {\n            const relay = getRelayProtocolName(opts);\n            const params = { topic, relay };\n            this.pending.set(topic, params);\n            const id = await this.rpcSubscribe(topic, relay);\n            await this.onSubscribe(id, params);\n            this.logger.debug(`Successfully Subscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n            return id;\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Subscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async unsubscribe(topic, opts) {\n        if (typeof (opts === null || opts === void 0 ? void 0 : opts.id) !== \"undefined\") {\n            await this.unsubscribeById(topic, opts.id, opts);\n        }\n        else {\n            await this.unsubscribeByTopic(topic, opts);\n        }\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async enable() {\n        if (!this.cached.length)\n            return;\n        this.onEnable();\n    }\n    async disable() {\n        if (this.cached.length)\n            return;\n        this.onDisable();\n    }\n    async hasSubscription(id, topic) {\n        await this.isEnabled();\n        let result = false;\n        try {\n            const subscription = await this.getSubscription(id);\n            result = subscription.topic === topic;\n        }\n        catch (e) {\n        }\n        return result;\n    }\n    onEnable() {\n        this.cached = [];\n        this.events.emit(SUBSCRIBER_EVENTS.enabled);\n    }\n    onDisable() {\n        this.cached = this.values;\n        this.subscriptions.clear();\n        this.topicMap.clear();\n        this.events.emit(SUBSCRIBER_EVENTS.disabled);\n    }\n    async unsubscribeByTopic(topic, opts) {\n        const ids = this.topicMap.get(topic);\n        await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n    }\n    async unsubscribeById(topic, id, opts) {\n        this.logger.debug(`Unsubscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n        try {\n            const relay = getRelayProtocolName(opts);\n            await this.rpcUnsubscribe(topic, id, relay);\n            const reason = ERROR.DELETED.format({ context: formatMessageContext(this.context) });\n            await this.onUnsubscribe(topic, id, reason);\n            this.logger.debug(`Successfully Unsubscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Unsubscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async rpcSubscribe(topic, relay) {\n        const api = getRelayProtocolApi(relay.protocol);\n        const request = {\n            method: api.subscribe,\n            params: {\n                topic,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.relayer.provider.request(request);\n    }\n    async rpcUnsubscribe(topic, id, relay) {\n        const api = getRelayProtocolApi(relay.protocol);\n        const request = {\n            method: api.unsubscribe,\n            params: {\n                topic,\n                id,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.relayer.provider.request(request);\n    }\n    async onSubscribe(id, params) {\n        await this.setSubscription(id, Object.assign(Object.assign({}, params), { id }));\n        this.pending.delete(params.topic);\n    }\n    async onResubscribe(id, params) {\n        await this.addSubscription(id, Object.assign(Object.assign({}, params), { id }));\n        this.pending.delete(params.topic);\n    }\n    async onUnsubscribe(topic, id, reason) {\n        this.events.removeAllListeners(id);\n        if (await this.hasSubscription(id, topic)) {\n            await this.deleteSubscription(id, reason);\n        }\n        await this.relayer.history.delete(topic);\n    }\n    async setSubscription(id, subscription) {\n        await this.isEnabled();\n        if (this.subscriptions.has(id))\n            return;\n        this.logger.debug(`Setting subscription`);\n        this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n        await this.addSubscription(id, subscription);\n    }\n    async addSubscription(id, subscription) {\n        this.subscriptions.set(id, Object.assign({}, subscription));\n        this.topicMap.set(subscription.topic, id);\n        this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n    }\n    async getSubscription(id) {\n        await this.isEnabled();\n        this.logger.debug(`Getting subscription`);\n        this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n        const subscription = this.subscriptions.get(id);\n        if (!subscription) {\n            const error = ERROR.NO_MATCHING_ID.format({\n                context: formatMessageContext(this.context),\n                id,\n            });\n            throw new Error(error.message);\n        }\n        return subscription;\n    }\n    async deleteSubscription(id, reason) {\n        await this.isEnabled();\n        this.logger.debug(`Deleting subscription`);\n        this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n        const subscription = await this.getSubscription(id);\n        this.subscriptions.delete(id);\n        this.topicMap.delete(subscription.topic, id);\n        this.events.emit(SUBSCRIBER_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));\n    }\n    async persist() {\n        await this.relayer.storage.setRelayerSubscriptions(this.context, this.values);\n        this.events.emit(SUBSCRIBER_EVENTS.sync);\n    }\n    async restore() {\n        try {\n            const persisted = await this.relayer.storage.getRelayerSubscriptions(this.context);\n            if (typeof persisted === \"undefined\")\n                return;\n            if (!persisted.length)\n                return;\n            if (this.subscriptions.size) {\n                const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n                    context: formatMessageContext(this.context),\n                });\n                this.logger.error(error.message);\n                throw new Error(error.message);\n            }\n            this.cached = persisted;\n            this.logger.debug(`Successfully Restored subscriptions for ${formatMessageContext(this.context)}`);\n            this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Restore subscriptions for ${formatMessageContext(this.context)}`);\n            this.logger.error(e);\n        }\n    }\n    async initialize() {\n        await this.restore();\n        await this.reset();\n        await this.enable();\n    }\n    async isEnabled() {\n        if (!this.cached.length)\n            return;\n        return new Promise(resolve => {\n            this.events.once(SUBSCRIBER_EVENTS.enabled, () => resolve());\n        });\n    }\n    async reset() {\n        if (!this.cached.length)\n            return;\n        await Promise.all(this.cached.map(async (subscription) => this.resubscribe(subscription)));\n    }\n    async resubscribe(subscription) {\n        const { topic, relay } = subscription;\n        const params = { topic, relay };\n        this.pending.set(params.topic, params);\n        const id = await this.rpcSubscribe(params.topic, params.relay);\n        await this.onResubscribe(id, params);\n        if (this.ids.includes(subscription.id)) {\n            const reason = ERROR.RESUBSCRIBED.format({ topic: subscription.topic });\n            await this.deleteSubscription(subscription.id, reason);\n        }\n    }\n    async onConnect() {\n        await this.reset();\n        await this.enable();\n    }\n    async onDisconnect() {\n        await this.disable();\n    }\n    checkPending() {\n        this.pending.forEach(async (params) => {\n            const id = await this.rpcSubscribe(params.topic, params.relay);\n            await this.onSubscribe(id, params);\n        });\n    }\n    registerEventListeners() {\n        this.relayer.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n            this.checkPending();\n        });\n        this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n            await this.onConnect();\n        });\n        this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n            await this.onDisconnect();\n        });\n        this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent) => {\n            const eventName = SUBSCRIBER_EVENTS.created;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n            await this.persist();\n        });\n        this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent) => {\n            const eventName = SUBSCRIBER_EVENTS.deleted;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n            await this.persist();\n        });\n    }\n}\n//# sourceMappingURL=subscriber.js.map"]},"metadata":{},"sourceType":"module"}