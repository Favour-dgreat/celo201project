{"ast":null,"code":"import { create as ipfsHttpClient } from \"ipfs-http-client\";\nimport axios from \"axios\";\nimport { ethers } from \"ethers\"; // initialize IPFS\n\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\"); // mint an NFT\n\nexport const createNft = async (minterContract, performActions, _ref) => {\n  let {\n    name,\n    price,\n    description,\n    ipfsImage,\n    ownerAddress\n  } = _ref;\n  await performActions(async kit => {\n    if (!name || !description || !ipfsImage) return;\n    const {\n      defaultAccount\n    } = kit; // convert NFT metadata to JSON format\n\n    const data = JSON.stringify({\n      name,\n      price,\n      description,\n      image: ipfsImage,\n      owner: defaultAccount\n    });\n\n    try {\n      // save NFT metadata to IPFS\n      const added = await client.add(data); // IPFS url for uploaded metadata\n\n      const url = `https://ipfs.infura.io/ipfs/${added.path}`;\n\n      const _price = ethers.utils.parseUnits(String(price), \"ether\"); // mint the NFT and save the IPFS url to the blockchain\n\n\n      let transaction = await minterContract.methods.safeMint(url, _price).send({\n        from: defaultAccount\n      });\n      return transaction;\n    } catch (error) {\n      console.log(\"Error uploading file: \", error);\n    }\n  });\n}; // function to upload a file to IPFS\n\nexport const uploadToIpfs = async e => {\n  const file = e.target.files[0];\n  if (!file) return;\n\n  try {\n    const added = await client.add(file, {\n      progress: prog => console.log(`received: ${prog}`)\n    });\n    return `https://ipfs.infura.io/ipfs/${added.path}`;\n  } catch (error) {\n    console.log(\"Error uploading file: \", error);\n  }\n}; // fetch all NFTs on the smart contract\n\nexport const getNfts = async minterContract => {\n  try {\n    const nfts = [];\n    const nftsLength = await minterContract.methods.getImageLength().call();\n\n    for (let i = 0; i < Number(nftsLength); i++) {\n      const nft = new Promise(async resolve => {\n        const image = await minterContract.methods.getImage(i).call();\n        const res = await minterContract.methods.tokenURI(i).call();\n        const meta = await fetchNftMeta(res);\n        const owner = await fetchNftOwner(minterContract, i);\n        resolve({\n          index: i,\n          tokenId: i,\n          owner,\n          price: image.price,\n          sold: image.sold,\n          name: meta.data.name,\n          image: meta.data.image,\n          description: meta.data.description\n        });\n      });\n      nfts.push(nft);\n    }\n\n    return Promise.all(nfts);\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the metedata for an NFT from IPFS\n\nexport const fetchNftMeta = async ipfsUrl => {\n  try {\n    if (!ipfsUrl) return null;\n    const meta = await axios.get(ipfsUrl);\n    return meta;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the owner address of an NFT\n\nexport const fetchNftOwner = async (minterContract, index) => {\n  try {\n    return await minterContract.methods.ownerOf(index).call();\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the address that deployed the NFT contract\n\nexport const fetchNftContractOwner = async minterContract => {\n  try {\n    let owner = await minterContract.methods.owner().call();\n    return owner;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n};\nexport const transferOwnership = async (minterContract, ownerAddress, newAddress, tokenId, performActions) => {\n  try {\n    await performActions(async kit => {\n      const {\n        defaultAccount\n      } = kit; // console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n\n      await minterContract.methods.makeTransfer(ownerAddress, newAddress, tokenId).send({\n        from: defaultAccount\n      });\n    });\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};\nexport const buyImage = async (minterContract, index, tokenId, performActions) => {\n  try {\n    await performActions(async kit => {\n      const {\n        defaultAccount\n      } = kit; // console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n\n      const image = await minterContract.methods.getImage(index).call();\n      await minterContract.methods.buyImage(tokenId).send({\n        from: defaultAccount,\n        value: image.price\n      });\n    });\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};\nexport const sellImage = async (minterContract, tokenId, performActions) => {\n  try {\n    await performActions(async kit => {\n      const {\n        defaultAccount\n      } = kit;\n      await minterContract.methods.sellImage(tokenId).send({\n        from: defaultAccount\n      });\n    });\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};\nexport const getOwners = async minterContract => {\n  try {\n    const ownerCount = await minterContract.methods.getOwners().call();\n    return ownerCount;\n  } catch (error) {\n    console.log({\n      error\n    });\n  }\n};","map":{"version":3,"sources":["/Users/dgreat/Gtas/celo201project/src/utils/minter.js"],"names":["create","ipfsHttpClient","axios","ethers","client","createNft","minterContract","performActions","name","price","description","ipfsImage","ownerAddress","kit","defaultAccount","data","JSON","stringify","image","owner","added","add","url","path","_price","utils","parseUnits","String","transaction","methods","safeMint","send","from","error","console","log","uploadToIpfs","e","file","target","files","progress","prog","getNfts","nfts","nftsLength","getImageLength","call","i","Number","nft","Promise","resolve","getImage","res","tokenURI","meta","fetchNftMeta","fetchNftOwner","index","tokenId","sold","push","all","ipfsUrl","get","ownerOf","fetchNftContractOwner","transferOwnership","newAddress","makeTransfer","buyImage","value","sellImage","getOwners","ownerCount"],"mappings":"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","sourcesContent":["import { create as ipfsHttpClient } from \"ipfs-http-client\";\nimport axios from \"axios\";\nimport { ethers } from \"ethers\";\n\n// initialize IPFS\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\");\n\n// mint an NFT\nexport const createNft = async (\n  minterContract,\n  performActions,\n  { name,price, description, ipfsImage, ownerAddress }\n) => {\n  await performActions(async (kit) => {\n    if (!name || !description || !ipfsImage) return;\n    const { defaultAccount } = kit;\n\n    // convert NFT metadata to JSON format\n    const data = JSON.stringify({\n      name,\n      price,\n      description,\n      image: ipfsImage,\n      owner: defaultAccount\n    });\n\n    try {\n      // save NFT metadata to IPFS\n      const added = await client.add(data);\n\n      // IPFS url for uploaded metadata\n      const url = `https://ipfs.infura.io/ipfs/${added.path}`;\n      const _price = ethers.utils.parseUnits(String(price), \"ether\");\n\n\n      // mint the NFT and save the IPFS url to the blockchain\n      let transaction = await minterContract.methods\n        .safeMint(url, _price)\n        .send({ from: defaultAccount });\n\n      return transaction;\n    } catch (error) {\n      console.log(\"Error uploading file: \", error);\n    }\n  });\n};\n\n// function to upload a file to IPFS\nexport const uploadToIpfs = async (e) => {\n  const file = e.target.files[0];\n  if (!file) return;\n  try {\n    const added = await client.add(file, {\n      progress: (prog) => console.log(`received: ${prog}`),\n    });\n    return `https://ipfs.infura.io/ipfs/${added.path}`;\n  } catch (error) {\n    console.log(\"Error uploading file: \", error);\n  }\n};\n\n// fetch all NFTs on the smart contract\nexport const getNfts = async (minterContract) => {\n  try {\n    const nfts = [];\n    const nftsLength = await minterContract.methods.getImageLength().call();\n    for (let i = 0; i < Number(nftsLength); i++) {\n      const nft = new Promise(async (resolve) => {\n        const image = await minterContract.methods.getImage(i).call();\n        const res = await minterContract.methods.tokenURI(i).call();\n        const meta = await fetchNftMeta(res);\n        const owner = await fetchNftOwner(minterContract, i);\n        resolve({\n          index: i,\n          tokenId: i,\n          owner,\n          price: image.price,\n          sold: image.sold,\n          name: meta.data.name,\n          image: meta.data.image,\n          description: meta.data.description        });\n      });\n      nfts.push(nft);\n    }\n    return Promise.all(nfts);\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the metedata for an NFT from IPFS\nexport const fetchNftMeta = async (ipfsUrl) => {\n  try {\n    if (!ipfsUrl) return null;\n    const meta = await axios.get(ipfsUrl);\n    return meta;\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the owner address of an NFT\nexport const fetchNftOwner = async (minterContract, index) => {\n  try {\n    return await minterContract.methods.ownerOf(index).call();\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\n// get the address that deployed the NFT contract\nexport const fetchNftContractOwner = async (minterContract) => {\n  try {\n    let owner = await minterContract.methods.owner().call();\n    return owner;\n  } catch (e) {\n    console.log({ e });\n  }\n};\n\nexport const transferOwnership = async (\n  minterContract,\n  ownerAddress,\n  newAddress,\n  tokenId,\n  performActions\n) => {\n  try {\n    await performActions(async (kit) => {\n      const { defaultAccount } = kit;\n      // console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n      await minterContract.methods\n        .makeTransfer(ownerAddress, newAddress, tokenId)\n        .send({ from: defaultAccount });\n    });\n  } catch (error) {\n    console.log({ error });\n  }\n};\nexport const buyImage = async (\n  minterContract,\n  index,\n  tokenId,\n  performActions\n) => {\n  try {\n    await performActions(async (kit) => {\n      const { defaultAccount } = kit;\n      // console.log(ownerAddress, newAddress, tokenId, defaultAccount);\n      const image = await minterContract.methods.getImage(index).call();\n      await minterContract.methods\n        .buyImage(tokenId)\n        .send({ from: defaultAccount, value: image.price });\n    });\n  } catch (error) {\n    console.log({ error });\n  }\n};\nexport const sellImage = async (minterContract, tokenId, performActions) => {\n  try {\n    await performActions(async (kit) => {\n      const { defaultAccount } = kit;\n      await minterContract.methods\n        .sellImage(tokenId)\n        .send({ from: defaultAccount });\n    });\n  } catch (error) {\n    console.log({ error });\n  }\n};\nexport const getOwners = async (minterContract) => {\n  try {\n    const ownerCount = await minterContract.methods.getOwners().call();\n    return ownerCount;\n  } catch (error) {\n    console.log({ error });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}