{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { IExpirer } from \"@walletconnect/types\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { ERROR, formatMessageContext, toMiliseconds } from \"@walletconnect/utils\";\nimport { EXPIRER_CONTEXT, EXPIRER_EVENTS, HEARTBEAT_EVENTS } from \"../constants\";\nexport class Expirer extends IExpirer {\n  constructor(client, logger) {\n    super(client, logger);\n    this.client = client;\n    this.logger = logger;\n    this.expirations = new Map();\n    this.events = new EventEmitter();\n    this.name = EXPIRER_CONTEXT;\n    this.cached = [];\n    this.client;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get length() {\n    return this.expirations.size;\n  }\n\n  get topics() {\n    return Array.from(this.expirations.keys());\n  }\n\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.initialize();\n  }\n\n  async has(topic) {\n    try {\n      const expiration = this.getExpiration(topic);\n      return typeof expiration !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n\n  async set(topic, expiration) {\n    await this.isInitialized();\n    this.expirations.set(topic, expiration);\n    this.checkExpiry(topic, expiration);\n    this.events.emit(EXPIRER_EVENTS.created, {\n      topic,\n      expiration\n    });\n  }\n\n  async get(topic) {\n    await this.isInitialized();\n    return this.getExpiration(topic);\n  }\n\n  async del(topic) {\n    await this.isInitialized();\n    const expiration = this.getExpiration(topic);\n    this.expirations.delete(topic);\n    this.events.emit(EXPIRER_EVENTS.deleted, {\n      topic,\n      expiration\n    });\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async persist() {\n    await this.client.storage.setSequenceStore(this.context, this.values);\n    this.events.emit(EXPIRER_EVENTS.sync);\n  }\n\n  async restore() {\n    try {\n      const persisted = await this.client.storage.getSequenceStore(this.context);\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n\n      if (this.expirations.size) {\n        const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n          context: formatMessageContext(this.context)\n        });\n        this.logger.error(error.message);\n        throw new Error(error.message);\n      }\n\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored expirations for ${formatMessageContext(this.context)}`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${formatMessageContext(this.context)}`);\n      this.logger.error(e);\n    }\n  }\n\n  async initialize() {\n    await this.restore();\n    this.reset();\n    this.onInit();\n  }\n\n  reset() {\n    this.cached.forEach(expiration => this.expirations.set(expiration.topic, expiration));\n  }\n\n  onInit() {\n    this.cached = [];\n    this.events.emit(EXPIRER_EVENTS.init);\n  }\n\n  async isInitialized() {\n    if (!this.cached.length) return;\n    return new Promise(resolve => {\n      this.events.once(EXPIRER_EVENTS.init, () => resolve());\n    });\n  }\n\n  getExpiration(topic) {\n    const expiration = this.expirations.get(topic);\n\n    if (!expiration) {\n      const error = ERROR.NO_MATCHING_ID.format({\n        context: formatMessageContext(this.context),\n        topic\n      });\n      throw new Error(error.message);\n    }\n\n    return expiration;\n  }\n\n  checkExpiry(topic, expiration) {\n    const {\n      expiry\n    } = expiration;\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(topic, expiration);\n  }\n\n  expire(topic, expiration) {\n    this.expirations.delete(topic);\n    this.events.emit(EXPIRER_EVENTS.expired, {\n      topic,\n      expiration\n    });\n  }\n\n  checkExpirations() {\n    this.expirations.forEach((expiration, topic) => this.checkExpiry(topic, expiration));\n  }\n\n  registerEventListeners() {\n    this.client.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n    this.events.on(EXPIRER_EVENTS.created, createdEvent => {\n      const eventName = EXPIRER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: createdEvent\n      });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.expired, expiredEvent => {\n      const eventName = EXPIRER_EVENTS.expired;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: expiredEvent\n      });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.deleted, deletedEvent => {\n      const eventName = EXPIRER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: deletedEvent\n      });\n      this.persist();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/expirer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { IExpirer } from \"@walletconnect/types\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { ERROR, formatMessageContext, toMiliseconds } from \"@walletconnect/utils\";\nimport { EXPIRER_CONTEXT, EXPIRER_EVENTS, HEARTBEAT_EVENTS } from \"../constants\";\nexport class Expirer extends IExpirer {\n    constructor(client, logger) {\n        super(client, logger);\n        this.client = client;\n        this.logger = logger;\n        this.expirations = new Map();\n        this.events = new EventEmitter();\n        this.name = EXPIRER_CONTEXT;\n        this.cached = [];\n        this.client;\n        this.logger = generateChildLogger(logger, this.name);\n        this.registerEventListeners();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get length() {\n        return this.expirations.size;\n    }\n    get topics() {\n        return Array.from(this.expirations.keys());\n    }\n    get values() {\n        return Array.from(this.expirations.values());\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.initialize();\n    }\n    async has(topic) {\n        try {\n            const expiration = this.getExpiration(topic);\n            return typeof expiration !== \"undefined\";\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async set(topic, expiration) {\n        await this.isInitialized();\n        this.expirations.set(topic, expiration);\n        this.checkExpiry(topic, expiration);\n        this.events.emit(EXPIRER_EVENTS.created, {\n            topic,\n            expiration,\n        });\n    }\n    async get(topic) {\n        await this.isInitialized();\n        return this.getExpiration(topic);\n    }\n    async del(topic) {\n        await this.isInitialized();\n        const expiration = this.getExpiration(topic);\n        this.expirations.delete(topic);\n        this.events.emit(EXPIRER_EVENTS.deleted, {\n            topic,\n            expiration,\n        });\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async persist() {\n        await this.client.storage.setSequenceStore(this.context, this.values);\n        this.events.emit(EXPIRER_EVENTS.sync);\n    }\n    async restore() {\n        try {\n            const persisted = await this.client.storage.getSequenceStore(this.context);\n            if (typeof persisted === \"undefined\")\n                return;\n            if (!persisted.length)\n                return;\n            if (this.expirations.size) {\n                const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n                    context: formatMessageContext(this.context),\n                });\n                this.logger.error(error.message);\n                throw new Error(error.message);\n            }\n            this.cached = persisted;\n            this.logger.debug(`Successfully Restored expirations for ${formatMessageContext(this.context)}`);\n            this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Restore expirations for ${formatMessageContext(this.context)}`);\n            this.logger.error(e);\n        }\n    }\n    async initialize() {\n        await this.restore();\n        this.reset();\n        this.onInit();\n    }\n    reset() {\n        this.cached.forEach(expiration => this.expirations.set(expiration.topic, expiration));\n    }\n    onInit() {\n        this.cached = [];\n        this.events.emit(EXPIRER_EVENTS.init);\n    }\n    async isInitialized() {\n        if (!this.cached.length)\n            return;\n        return new Promise(resolve => {\n            this.events.once(EXPIRER_EVENTS.init, () => resolve());\n        });\n    }\n    getExpiration(topic) {\n        const expiration = this.expirations.get(topic);\n        if (!expiration) {\n            const error = ERROR.NO_MATCHING_ID.format({\n                context: formatMessageContext(this.context),\n                topic,\n            });\n            throw new Error(error.message);\n        }\n        return expiration;\n    }\n    checkExpiry(topic, expiration) {\n        const { expiry } = expiration;\n        const msToTimeout = toMiliseconds(expiry) - Date.now();\n        if (msToTimeout <= 0)\n            this.expire(topic, expiration);\n    }\n    expire(topic, expiration) {\n        this.expirations.delete(topic);\n        this.events.emit(EXPIRER_EVENTS.expired, {\n            topic,\n            expiration,\n        });\n    }\n    checkExpirations() {\n        this.expirations.forEach((expiration, topic) => this.checkExpiry(topic, expiration));\n    }\n    registerEventListeners() {\n        this.client.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n        this.events.on(EXPIRER_EVENTS.created, (createdEvent) => {\n            const eventName = EXPIRER_EVENTS.created;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n            this.persist();\n        });\n        this.events.on(EXPIRER_EVENTS.expired, (expiredEvent) => {\n            const eventName = EXPIRER_EVENTS.expired;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n            this.persist();\n        });\n        this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent) => {\n            const eventName = EXPIRER_EVENTS.deleted;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n            this.persist();\n        });\n    }\n}\n//# sourceMappingURL=expirer.js.map"]},"metadata":{},"sourceType":"module"}